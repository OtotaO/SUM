// src/App.js
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { ChakraProvider, extendTheme } from '@chakra-ui/react';

// Import components
import Navbar from './components/Navbar';
import Sidebar from './components/Sidebar';
import Dashboard from './pages/Dashboard';
import Summarizer from './pages/Summarizer';
import TopicModeling from './pages/TopicModeling';
import KnowledgeGraph from './pages/KnowledgeGraph';
import TemporalAnalysis from './pages/TemporalAnalysis';
import Settings from './pages/Settings';
import BatchProcessor from './pages/BatchProcessor';
import EntityExtraction from './pages/EntityExtraction';
import Documentation from './pages/Documentation';

// Import context providers
import { AppProvider } from './context/AppContext';

// Define theme
const theme = extendTheme({
  colors: {
    brand: {
      50: '#e6f6ff',
      100: '#c0e4ff',
      200: '#9aceff',
      300: '#71b8ff',
      400: '#4da3ff',
      500: '#2a8cff',
      600: '#0069d9',
      700: '#004ea7',
      800: '#003475',
      900: '#001b44',
    },
    accent: {
      50: '#fff5e6',
      100: '#ffe5c0',
      200: '#ffd59a',
      300: '#ffc671',
      400: '#ffb547',
      500: '#ffa31d',
      600: '#d97f00',
      700: '#a75e00',
      800: '#754000',
      900: '#442200',
    },
  },
  fonts: {
    heading: '"Inter", sans-serif',
    body: '"Inter", sans-serif',
  },
  components: {
    Button: {
      baseStyle: {
        fontWeight: 'medium',
        borderRadius: 'md',
      },
      variants: {
        solid: {
          bg: 'brand.500',
          color: 'white',
          _hover: {
            bg: 'brand.600',
          },
        },
        outline: {
          borderColor: 'brand.500',
          color: 'brand.500',
          _hover: {
            bg: 'brand.50',
          },
        },
      },
    },
  },
});

function App() {
  return (
    <ChakraProvider theme={theme}>
      <AppProvider>
        <Router>
          <div className="app">
            <Navbar />
            <div className="container">
              <Sidebar />
              <main className="content">
                <Routes>
                  <Route path="/" element={<Dashboard />} />
                  <Route path="/summarizer" element={<Summarizer />} />
                  <Route path="/topics" element={<TopicModeling />} />
                  <Route path="/knowledge-graph" element={<KnowledgeGraph />} />
                  <Route path="/temporal" element={<TemporalAnalysis />} />
                  <Route path="/entities" element={<EntityExtraction />} />
                  <Route path="/batch" element={<BatchProcessor />} />
                  <Route path="/settings" element={<Settings />} />
                  <Route path="/docs" element={<Documentation />} />
                </Routes>
              </main>
            </div>
          </div>
        </Router>
      </AppProvider>
    </ChakraProvider>
  );
}

export default App;

// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// src/index.css
:root {
  --sidebar-width: 260px;
  --navbar-height: 64px;
}

body {
  margin: 0;
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

.app {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.container {
  display: flex;
  flex: 1;
  min-height: calc(100vh - var(--navbar-height));
}

.content {
  flex: 1;
  padding: 1.5rem;
  overflow-y: auto;
  max-width: calc(100vw - var(--sidebar-width));
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .content {
    max-width: 100vw;
  }
}

/* src/context/AppContext.js */
import React, { createContext, useContext, useState, useEffect } from 'react';

const AppContext = createContext();

export function useAppContext() {
  return useContext(AppContext);
}

export function AppProvider({ children }) {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [darkMode, setDarkMode] = useState(false);
  const [userSettings, setUserSettings] = useState({
    defaultModel: 'advanced',
    maxTokens: 200,
    minTokens: 50,
    defaultFormat: 'json',
    apiKey: '',
  });

  // Load settings from local storage on mount
  useEffect(() => {
    const savedSettings = localStorage.getItem('sum_settings');
    if (savedSettings) {
      setUserSettings(JSON.parse(savedSettings));
    }
    
    const savedDarkMode = localStorage.getItem('sum_dark_mode');
    if (savedDarkMode) {
      setDarkMode(JSON.parse(savedDarkMode));
    }
  }, []);

  // Save settings to local storage when they change
  useEffect(() => {
    localStorage.setItem('sum_settings', JSON.stringify(userSettings));
  }, [userSettings]);

  useEffect(() => {
    localStorage.setItem('sum_dark_mode', JSON.stringify(darkMode));
  }, [darkMode]);

  // Generic API request function
  const apiRequest = async (endpoint, method = 'GET', data = null) => {
    setIsLoading(true);
    setError(null);

    const options = {
      method,
      headers: {
        'Content-Type': 'application/json',
      },
    };

    if (data) {
      if (data instanceof FormData) {
        options.body = data;
        delete options.headers['Content-Type'];
      } else {
        options.body = JSON.stringify(data);
      }
    }

    try {
      const response = await fetch(`/api/${endpoint}`, options);
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'An error occurred');
      }
      
      const responseData = await response.json();
      setIsLoading(false);
      return responseData;
    } catch (error) {
      setError(error.message);
      setIsLoading(false);
      throw error;
    }
  };

  // Context value
  const value = {
    isLoading,
    setIsLoading,
    error,
    setError,
    sidebarOpen,
    setSidebarOpen,
    darkMode,
    setDarkMode,
    userSettings,
    setUserSettings,
    apiRequest,
  };

  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;
}

// src/components/Navbar.js
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Flex,
  Text,
  IconButton,
  Button,
  Stack,
  Collapse,
  Icon,
  Link,
  Popover,
  PopoverTrigger,
  PopoverContent,
  useColorModeValue,
  useDisclosure,
  useColorMode,
} from '@chakra-ui/react';
import {
  HamburgerIcon,
  CloseIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  MoonIcon,
  SunIcon,
} from '@chakra-ui/icons';
import { useAppContext } from '../context/AppContext';

function Navbar() {
  const { isOpen, onToggle } = useDisclosure();
  const { colorMode, toggleColorMode } = useColorMode();
  const { sidebarOpen, setSidebarOpen } = useAppContext();

  return (
    <Box>
      <Flex
        bg={useColorModeValue('white', 'gray.800')}
        color={useColorModeValue('gray.600', 'white')}
        minH={'60px'}
        py={{ base: 2 }}
        px={{ base: 4 }}
        borderBottom={1}
        borderStyle={'solid'}
        borderColor={useColorModeValue('gray.200', 'gray.700')}
        align={'center'}
      >
        <Flex
          flex={{ base: 1, md: 'auto' }}
          ml={{ base: -2 }}
          display={{ base: 'flex', md: 'none' }}
        >
          <IconButton
            onClick={onToggle}
            icon={
              isOpen ? <CloseIcon w={3} h={3} /> : <HamburgerIcon w={5} h={5} />
            }
            variant={'ghost'}
            aria-label={'Toggle Navigation'}
          />
        </Flex>
        <Flex flex={{ base: 1 }} justify={{ base: 'center', md: 'start' }}>
          <Text
            textAlign={useColorModeValue('left', 'center')}
            fontFamily={'heading'}
            color={useColorModeValue('gray.800', 'white')}
            fontWeight={'bold'}
            fontSize="xl"
            as={RouterLink}
            to="/"
          >
            SUM
          </Text>

          <Flex display={{ base: 'none', md: 'flex' }} ml={10}>
            <DesktopNav />
          </Flex>
        </Flex>

        <Stack
          flex={{ base: 1, md: 0 }}
          justify={'flex-end'}
          direction={'row'}
          spacing={6}
        >
          <IconButton
            aria-label={'Toggle sidebar'}
            icon={<HamburgerIcon />}
            display={{ base: 'none', md: 'inline-flex' }}
            onClick={() => setSidebarOpen(!sidebarOpen)}
          />
          <IconButton
            aria-label={'Toggle color mode'}
            icon={colorMode === 'light' ? <MoonIcon /> : <SunIcon />}
            onClick={toggleColorMode}
          />
        </Stack>
      </Flex>

      <Collapse in={isOpen} animateOpacity>
        <MobileNav />
      </Collapse>
    </Box>
  );
}

const DesktopNav = () => {
  const linkColor = useColorModeValue('gray.600', 'gray.200');
  const linkHoverColor = useColorModeValue('gray.800', 'white');
  const popoverContentBgColor = useColorModeValue('white', 'gray.800');

  return (
    <Stack direction={'row'} spacing={4}>
      {NAV_ITEMS.map((navItem) => (
        <Box key={navItem.label}>
          <Popover trigger={'hover'} placement={'bottom-start'}>
            <PopoverTrigger>
              <Link
                p={2}
                as={RouterLink}
                to={navItem.href ?? '#'}
                fontSize={'sm'}
                fontWeight={500}
                color={linkColor}
                _hover={{
                  textDecoration: 'none',
                  color: linkHoverColor,
                }}
              >
                {navItem.label}
                {navItem.children && (
                  <Icon
                    as={ChevronDownIcon}
                    transition={'all .25s ease-in-out'}
                    transform={'translateY(1px)'}
                    w={4}
                    h={4}
                  />
                )}
              </Link>
            </PopoverTrigger>

            {navItem.children && (
              <PopoverContent
                border={0}
                boxShadow={'xl'}
                bg={popoverContentBgColor}
                p={4}
                rounded={'xl'}
                minW={'sm'}
              >
                <Stack>
                  {navItem.children.map((child) => (
                    <DesktopSubNav key={child.label} {...child} />
                  ))}
                </Stack>
              </PopoverContent>
            )}
          </Popover>
        </Box>
      ))}
    </Stack>
  );
};

const DesktopSubNav = ({ label, href, subLabel }) => {
  return (
    <Link
      as={RouterLink}
      to={href}
      role={'group'}
      display={'block'}
      p={2}
      rounded={'md'}
      _hover={{ bg: useColorModeValue('brand.50', 'gray.900') }}
    >
      <Stack direction={'row'} align={'center'}>
        <Box>
          <Text
            transition={'all .3s ease'}
            _groupHover={{ color: 'brand.500' }}
            fontWeight={500}
          >
            {label}
          </Text>
          <Text fontSize={'sm'}>{subLabel}</Text>
        </Box>
        <Flex
          transition={'all .3s ease'}
          transform={'translateX(-10px)'}
          opacity={0}
          _groupHover={{ opacity: '100%', transform: 'translateX(0)' }}
          justify={'flex-end'}
          align={'center'}
          flex={1}
        >
          <Icon color={'brand.500'} w={5} h={5} as={ChevronRightIcon} />
        </Flex>
      </Stack>
    </Link>
  );
};

const MobileNav = () => {
  return (
    <Stack
      bg={useColorModeValue('white', 'gray.800')}
      p={4}
      display={{ md: 'none' }}
    >
      {NAV_ITEMS.map((navItem) => (
        <MobileNavItem key={navItem.label} {...navItem} />
      ))}
    </Stack>
  );
};

const MobileNavItem = ({ label, children, href }) => {
  const { isOpen, onToggle } = useDisclosure();

  return (
    <Stack spacing={4} onClick={children && onToggle}>
      <Flex
        py={2}
        as={RouterLink}
        to={href ?? '#'}
        justify={'space-between'}
        align={'center'}
        _hover={{
          textDecoration: 'none',
        }}
      >
        <Text
          fontWeight={600}
          color={useColorModeValue('gray.600', 'gray.200')}
        >
          {label}
        </Text>
        {children && (
          <Icon
            as={ChevronDownIcon}
            transition={'all .25s ease-in-out'}
            transform={isOpen ? 'rotate(180deg)' : ''}
            w={6}
            h={6}
          />
        )}
      </Flex>

      <Collapse in={isOpen} animateOpacity style={{ marginTop: '0!important' }}>
        <Stack
          mt={2}
          pl={4}
          borderLeft={1}
          borderStyle={'solid'}
          borderColor={useColorModeValue('gray.200', 'gray.700')}
          align={'start'}
        >
          {children &&
            children.map((child) => (
              <Link key={child.label} py={2} as={RouterLink} to={child.href}>
                {child.label}
              </Link>
            ))}
        </Stack>
      </Collapse>
    </Stack>
  );
};

const NAV_ITEMS = [
  {
    label: 'Features',
    children: [
      {
        label: 'Summarizer',
        subLabel: 'Generate concise summaries',
        href: '/summarizer',
      },
      {
        label: 'Topic Modeling',
        subLabel: 'Discover latent themes',
        href: '/topics',
      },
      {
        label: 'Knowledge Graph',
        subLabel: 'Visualize knowledge networks',
        href: '/knowledge-graph',
      },
      {
        label: 'Temporal Analysis',
        subLabel: 'Track concept evolution',
        href: '/temporal',
      },
      {
        label: 'Entity Extraction',
        subLabel: 'Identify key entities',
        href: '/entities',
      },
    ],
  },
  {
    label: 'Tools',
    children: [
      {
        label: 'Batch Processor',
        subLabel: 'Process multiple documents',
        href: '/batch',
      },
      {
        label: 'Settings',
        subLabel: 'Configure SUM platform',
        href: '/settings',
      },
    ],
  },
  {
    label: 'Documentation',
    href: '/docs',
  },
];

export default Navbar;

// src/components/Sidebar.js
import React from 'react';
import { Link as RouterLink, useLocation } from 'react-router-dom';
import {
  Box,
  Flex,
  Text,
  VStack,
  Icon,
  Link,
  Divider,
  useColorModeValue,
} from '@chakra-ui/react';
import {
  FiHome,
  FiFileText,
  FiGrid,
  FiShare2,
  FiClock,
  FiTag,
  FiLayers,
  FiSettings,
  FiBook,
} from 'react-icons/fi';
import { useAppContext } from '../context/AppContext';

function Sidebar() {
  const location = useLocation();
  const { sidebarOpen } = useAppContext();
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  if (!sidebarOpen) {
    return null;
  }
  
  return (
    <Box
      as="nav"
      pos="sticky"
      top="60px"
      left="0"
      h="calc(100vh - 60px)"
      w="260px"
      overflowY="auto"
      bg={bgColor}
      borderRight="1px"
      borderRightColor={borderColor}
      px="4"
      py="4"
      display={{ base: 'none', md: sidebarOpen ? 'block' : 'none' }}
    >
      <VStack spacing="4" align="stretch">
        <SidebarItem
          icon={FiHome}
          label="Dashboard"
          to="/"
          active={location.pathname === '/'}
        />
        
        <Divider my="2" />
        <Text px="3" fontSize="xs" fontWeight="bold" textTransform="uppercase" color="gray.500">
          Features
        </Text>
        
        <SidebarItem
          icon={FiFileText}
          label="Summarizer"
          to="/summarizer"
          active={location.pathname === '/summarizer'}
        />
        
        <SidebarItem
          icon={FiGrid}
          label="Topic Modeling"
          to="/topics"
          active={location.pathname === '/topics'}
        />
        
        <SidebarItem
          icon={FiShare2}
          label="Knowledge Graph"
          to="/knowledge-graph"
          active={location.pathname === '/knowledge-graph'}
        />
        
        <SidebarItem
          icon={FiClock}
          label="Temporal Analysis"
          to="/temporal"
          active={location.pathname === '/temporal'}
        />
        
        <SidebarItem
          icon={FiTag}
          label="Entity Extraction"
          to="/entities"
          active={location.pathname === '/entities'}
        />
        
        <Divider my="2" />
        <Text px="3" fontSize="xs" fontWeight="bold" textTransform="uppercase" color="gray.500">
          Tools
        </Text>
        
        <SidebarItem
          icon={FiLayers}
          label="Batch Processor"
          to="/batch"
          active={location.pathname === '/batch'}
        />
        
        <SidebarItem
          icon={FiSettings}
          label="Settings"
          to="/settings"
          active={location.pathname === '/settings'}
        />
        
        <Divider my="2" />
        
        <SidebarItem
          icon={FiBook}
          label="Documentation"
          to="/docs"
          active={location.pathname === '/docs'}
        />
      </VStack>
    </Box>
  );
}

function SidebarItem({ icon, label, to, active }) {
  const activeBg = useColorModeValue('brand.50', 'gray.700');
  const hoverBg = useColorModeValue('gray.100', 'gray.700');
  const activeColor = useColorModeValue('brand.600', 'brand.300');
  const color = useColorModeValue('gray.700', 'gray.200');
  
  return (
    <Link
      as={RouterLink}
      to={to}
      style={{ textDecoration: 'none' }}
      _focus={{ boxShadow: 'none' }}
    >
      <Flex
        align="center"
        p="3"
        borderRadius="md"
        role="group"
        cursor="pointer"
        bg={active ? activeBg : 'transparent'}
        color={active ? activeColor : color}
        _hover={{
          bg: hoverBg,
        }}
      >
        <Icon
          mr="3"
          fontSize="16"
          as={icon}
        />
        <Text fontSize="sm" fontWeight={active ? 'semibold' : 'medium'}>
          {label}
        </Text>
      </Flex>
    </Link>
  );
}

export default Sidebar;

// src/components/FileUpload.js
import React, { useState, useRef } from 'react';
import {
  Box,
  Button,
  Flex,
  FormControl,
  FormLabel,
  Icon,
  Input,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';
import { FiUploadCloud, FiFile, FiX } from 'react-icons/fi';

function FileUpload({ 
  onFileChange, 
  accept = ".txt,.pdf,.doc,.docx,.json,.csv,.md", 
  multiple = false 
}) {
  const [files, setFiles] = useState([]);
  const [isDragging, setIsDragging] = useState(false);
  const fileInputRef = useRef(null);
  
  const borderColor = useColorModeValue('gray.300', 'gray.600');
  const dragBorderColor = useColorModeValue('brand.300', 'brand.600');
  const fileBgColor = useColorModeValue('gray.50', 'gray.700');
  
  const handleFileChange = (event) => {
    const fileList = event.target.files;
    if (!fileList.length) return;
    
    const fileArray = Array.from(fileList);
    setFiles(multiple ? [...files, ...fileArray] : fileArray);
    
    if (onFileChange) {
      onFileChange(multiple ? [...files, ...fileArray] : fileArray);
    }
  };
  
  const handleDragOver = (event) => {
    event.preventDefault();
    setIsDragging(true);
  };
  
  const handleDragLeave = () => {
    setIsDragging(false);
  };
  
  const handleDrop = (event) => {
    event.preventDefault();
    setIsDragging(false);
    
    const fileList = event.dataTransfer.files;
    if (!fileList.length) return;
    
    const fileArray = Array.from(fileList);
    setFiles(multiple ? [...files, ...fileArray] : fileArray);
    
    if (onFileChange) {
      onFileChange(multiple ? [...files, ...fileArray] : fileArray);
    }
  };
  
  const removeFile = (indexToRemove) => {
    const newFiles = files.filter((_, index) => index !== indexToRemove);
    setFiles(newFiles);
    
    if (onFileChange) {
      onFileChange(newFiles);
    }
  };
  
  return (
    <FormControl>
      <FormLabel>Upload File{multiple ? 's' : ''}</FormLabel>
      
      <Box
        border="2px dashed"
        borderColor={isDragging ? dragBorderColor : borderColor}
        borderRadius="md"
        p={4}
        textAlign="center"
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        cursor="pointer"
        onClick={() => fileInputRef.current.click()}
      >
        <Input
          type="file"
          multiple={multiple}
          accept={accept}
          onChange={handleFileChange}
          ref={fileInputRef}
          display="none"
        />
        
        <Icon as={FiUploadCloud} boxSize={10} color="gray.500" mb={2} />
        
        <Text mb={2}>
          {isDragging
            ? 'Drop your file here'
            : `Drag and drop your file${multiple ? 's' : ''} here or click to browse`}
        </Text>
        
        <Text fontSize="sm" color="gray.500">
          Accepted formats: {accept.split(',').join(', ')}
        </Text>
      </Box>
      
      {files.length > 0 && (
        <Box mt={4}>
          <Text mb={2} fontWeight="medium">
            {files.length} file{files.length !== 1 ? 's' : ''} selected
          </Text>
          
          {files.map((file, index) => (
            <Flex
              key={`${file.name}-${index}`}
              align="center"
              bg={fileBgColor}
              p={2}
              borderRadius="md"
              mb={2}
            >
              <Icon as={FiFile} mr={2} />
              <Text flex="1" fontSize="sm" noOfLines={1}>
                {file.name} ({(file.size / 1024).toFixed(1)} KB)
              </Text>
              <Button
                size="xs"
                variant="ghost"
                colorScheme="red"
                onClick={() => removeFile(index)}
                ml={2}
              >
                <Icon as={FiX} />
              </Button>
            </Flex>
          ))}
        </Box>
      )}
    </FormControl>
  );
}

export default FileUpload;

// src/components/ResultViewer.js
import React from 'react';
import {
  Box,
  Code,
  Flex,
  Heading,
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  Tabs,
  Tag,
  Text,
  VStack,
  useColorModeValue,
  Button,
  IconButton,
} from '@chakra-ui/react';
import { FiDownload, FiCopy } from 'react-icons/fi';

function ResultViewer({ data, title = "Results" }) {
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  // Check if data is available
  if (!data) {
    return null;
  }

  // Handle different result types
  const downloadJson = () => {
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const copyToClipboard = () => {
    const json = JSON.stringify(data, null, 2);
    navigator.clipboard.writeText(json);
  };

  // Render summary results
  if (data.summary) {
    return (
      <Box
        p={4}
        borderWidth="1px"
        borderColor={borderColor}
        borderRadius="md"
        bg={bgColor}
        boxShadow="sm"
      >
        <Flex justify="space-between" align="center" mb={4}>
          <Heading size="md">{title}</Heading>
          <Flex>
            <IconButton
              icon={<FiCopy />}
              size="sm"
              variant="ghost"
              aria-label="Copy to clipboard"
              onClick={copyToClipboard}
              mr={2}
            />
            <IconButton
              icon={<FiDownload />}
              size="sm"
              variant="ghost"
              aria-label="Download JSON"
              onClick={downloadJson}
            />
          </Flex>
        </Flex>

        <Tabs variant="soft-rounded" colorScheme="brand" size="sm">
          <TabList>
            <Tab>Summary</Tab>
            {data.tags && <Tab>Tags</Tab>}
            {data.entities && <Tab>Entities</Tab>}
            <Tab>Details</Tab>
          </TabList>

          <TabPanels>
            <TabPanel>
              <VStack align="start" spacing={4}>
                {data.sum && (
                  <Box>
                    <Text fontWeight="medium" mb={1}>One-Sentence Summary:</Text>
                    <Text>{data.sum}</Text>
                  </Box>
                )}
                <Box>
                  <Text fontWeight="medium" mb={1}>Full Summary:</Text>
                  <Text>{data.summary}</Text>
                </Box>
              </VStack>
            </TabPanel>

            {data.tags && (
              <TabPanel>
                <Flex wrap="wrap" gap={2}>
                  {data.tags.map((tag, index) => (
                    <Tag key={index} colorScheme="brand" size="md">
                      {tag}
                    </Tag>
                  ))}
                </Flex>
              </TabPanel>
            )}

            {data.entities && (
              <TabPanel>
                <Box overflowX="auto">
                  <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <thead>
                      <tr>
                        <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid gray' }}>Entity</th>
                        <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid gray' }}>Type</th>
                        <th style={{ textAlign: 'left', padding: '8px', borderBottom: '1px solid gray' }}>Count</th>
                      </tr>
                    </thead>
                    <tbody>
                      {data.entities.map((entity, index) => (
                        <tr key={index}>
                          <td style={{ padding: '8px', borderBottom: '1px solid gray' }}>{entity[0]}</td>
                          <td style={{ padding: '8px', borderBottom: '1px solid gray' }}>{entity[1]}</td>
                          <td style={{ padding: '8px', borderBottom: '1px solid gray' }}>{entity[2]}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </Box>
              </TabPanel>
            )}

            <TabPanel>
              <Box overflowX="auto">
                <Code p={3} borderRadius="md" width="100%" fontSize="sm" whiteSpace="pre-wrap">
                  {JSON.stringify(data, null, 2)}
                </Code>
              </Box>
            </TabPanel>
          </TabPanels>
        </Tabs>
      </Box>
    );
  }

  // Default JSON viewer for other result types
  return (
    <Box
      p={4}
      borderWidth="1px"
      borderColor={borderColor}
      borderRadius="md"
      bg={bgColor}
      boxShadow="sm"
    >
      <Flex justify="space-between" align="center" mb={4}>
        <Heading size="md">{title}</Heading>
        <Flex>
          <IconButton
            icon={<FiCopy />}
            size="sm"
            variant="ghost"
            aria-label="Copy to clipboard"
            onClick={copyToClipboard}
            mr={2}
          />
          <IconButton
            icon={<FiDownload />}
            size="sm"
            variant="ghost"
            aria-label="Download JSON"
            onClick={downloadJson}
          />
        </Flex>
      </Flex>
      <Box overflowX="auto">
        <Code p={3} borderRadius="md" width="100%" fontSize="sm" whiteSpace="pre-wrap">
          {JSON.stringify(data, null, 2)}
        </Code>
      </Box>
    </Box>
  );
}

export default ResultViewer;

// src/pages/Dashboard.js
import React, { useState, useEffect } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Flex,
  Grid,
  Heading,
  Link,
  SimpleGrid,
  Stat,
  StatLabel,
  StatNumber,
  StatHelpText,
  Text,
  Button,
  Icon,
  useColorModeValue,
} from '@chakra-ui/react';
import {
  FiFileText,
  FiGrid,
  FiShare2,
  FiClock,
  FiTag,
  FiLayers,
  FiActivity,
  FiArrowRight,
} from 'react-icons/fi';
import { useAppContext } from '../context/AppContext';

function Dashboard() {
  const [stats, setStats] = useState({
    documentsProcessed: 0,
    summariesGenerated: 0,
    topicModels: 0,
    knowledgeGraphs: 0,
  });
  
  const [recentActivity, setRecentActivity] = useState([]);
  
  const { apiRequest, isLoading, error } = useAppContext();
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const statBgColor = useColorModeValue('gray.50', 'gray.700');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  useEffect(() => {
    // Mock data for the dashboard
    setStats({
      documentsProcessed: 128,
      summariesGenerated: 42,
      topicModels: 15,
      knowledgeGraphs: 7,
    });
    
    setRecentActivity([
      {
        id: 1,
        type: 'summary',
        title: 'Research paper summarization',
        timestamp: '2025-02-27T10:45:00Z',
      },
      {
        id: 2,
        type: 'topic',
        title: 'News articles topic analysis',
        timestamp: '2025-02-26T16:30:00Z',
      },
      {
        id: 3,
        type: 'graph',
        title: 'Product documentation knowledge graph',
        timestamp: '2025-02-25T09:15:00Z',
      },
      {
        id: 4,
        type: 'temporal',
        title: 'Quarterly report evolution',
        timestamp: '2025-02-24T14:20:00Z',
      },
    ]);
    
    // In a real application, you would fetch this data from the API
    // const fetchDashboardData = async () => {
    //   try {
    //     const data = await apiRequest('dashboard/stats');
    //     setStats(data.stats);
    //     setRecentActivity(data.recentActivity);
    //   } catch (error) {
    //     console.error('Error fetching dashboard data:', error);
    //   }
    // };
    
    // fetchDashboardData();
  }, []);
  
  return (
    <Box>
      <Heading size="lg" mb={6}>Dashboard</Heading>
      
      <SimpleGrid columns={{ base: 1, md: 2, lg: 4 }} spacing={5} mb={8}>
        <StatCard
          label="Documents Processed"
          value={stats.documentsProcessed}
          helpText="Total documents"
          icon={FiFileText}
          color="blue"
        />
        
        <StatCard
          label="Summaries"
          value={stats.summariesGenerated}
          helpText="Generated summaries"
          icon={FiFileText}
          color="green"
        />
        
        <StatCard
          label="Topic Models"
          value={stats.topicModels}
          helpText="Topic models created"
          icon={FiGrid}
          color="purple"
        />
        
        <StatCard
          label="Knowledge Graphs"
          value={stats.knowledgeGraphs}
          helpText="Knowledge graphs generated"
          icon={FiShare2}
          color="orange"
        />
      </SimpleGrid>
      
      <Grid templateColumns={{ base: '1fr', lg: '2fr 1fr' }} gap={6}>
        <Box
          p={5}
          bg={bgColor}
          borderRadius="lg"
          borderWidth="1px"
          borderColor={borderColor}
          boxShadow="sm"
        >
          <Flex justify="space-between" align="center" mb={4}>
            <Heading size="md">Features</Heading>
          </Flex>
          
          <SimpleGrid columns={{ base: 1, md: 2, lg: 3 }} spacing={5}>
            <FeatureCard
              title="Summarizer"
              description="Generate concise, multi-level summaries"
              icon={FiFileText}
              link="/summarizer"
            />
            
            <FeatureCard
              title="Topic Modeling"
              description="Discover latent themes in documents"
              icon={FiGrid}
              link="/topics"
            />
            
            <FeatureCard
              title="Knowledge Graph"
              description="Visualize knowledge networks"
              icon={FiShare2}
              link="/knowledge-graph"
            />
            
            <FeatureCard
              title="Temporal Analysis"
              description="Track concept evolution over time"
              icon={FiClock}
              link="/temporal"
            />
            
            <FeatureCard
              title="Entity Extraction"
              description="Identify key entities in content"
              icon={FiTag}
              link="/entities"
            />
            
            <FeatureCard
              title="Batch Processing"
              description="Process multiple documents at once"
              icon={FiLayers}
              link="/batch"
            />
          </SimpleGrid>
        </Box>
        
        <Box
          p={5}
          bg={bgColor}
          borderRadius="lg"
          borderWidth="1px"
          borderColor={borderColor}
          boxShadow="sm"
        >
          <Flex justify="space-between" align="center" mb={4}>
            <Heading size="md">Recent Activity</Heading>
          </Flex>
          
          {recentActivity.length > 0 ? (
            <Box>
              {recentActivity.map((activity) => (
                <ActivityItem key={activity.id} activity={activity} />
              ))}
            </Box>
          ) : (
            <Text color="gray.500">No recent activity</Text>
          )}
        </Box>
      </Grid>
    </Box>
  );
}

function StatCard({ label, value, helpText, icon, color }) {
  const bgColor = useColorModeValue('white', 'gray.800');
  const iconColor = useColorModeValue(`${color}.500`, `${color}.300`);
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  return (
    <Stat
      px={4}
      py={5}
      bg={bgColor}
      borderRadius="lg"
      borderWidth="1px"
      borderColor={borderColor}
      boxShadow="sm"
    >
      <Flex justifyContent="space-between">
        <Box>
          <StatLabel fontWeight="medium">{label}</StatLabel>
          <StatNumber fontSize="3xl" fontWeight="bold">
            {value}
          </StatNumber>
          <StatHelpText>{helpText}</StatHelpText>
        </Box>
        <Box
          my="auto"
          color={iconColor}
          alignContent="center"
        >
          <Icon as={icon} w={8} h={8} />
        </Box>
      </Flex>
    </Stat>
  );
}

function FeatureCard({ title, description, icon, link }) {
  const bgColor = useColorModeValue('gray.50', 'gray.700');
  const hoverBgColor = useColorModeValue('gray.100', 'gray.600');
  
  return (
    <Link
      as={RouterLink}
      to={link}
      _hover={{ textDecoration: 'none' }}
    >
      <Flex
        direction="column"
        p={5}
        bg={bgColor}
        borderRadius="lg"
        borderWidth="1px"
        borderColor="transparent"
        _hover={{ bg: hoverBgColor, borderColor: 'brand.200' }}
        transition="all 0.2s"
        height="100%"
      >
        <Flex align="center" mb={2}>
          <Icon as={icon} boxSize={5} mr={2} color="brand.500" />
          <Text fontWeight="semibold">{title}</Text>
        </Flex>
        <Text fontSize="sm" color="gray.500" flex="1">
          {description}
        </Text>
        <Flex mt={3} align="center" color="brand.500" fontSize="sm">
          <Text>Try now</Text>
          <Icon as={FiArrowRight} boxSize={3} ml={1} />
        </Flex>
      </Flex>
    </Link>
  );
}

function ActivityItem({ activity }) {
  const bgColor = useColorModeValue('gray.50', 'gray.700');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  const getActivityIcon = (type) => {
    switch (type) {
      case 'summary':
        return FiFileText;
      case 'topic':
        return FiGrid;
      case 'graph':
        return FiShare2;
      case 'temporal':
        return FiClock;
      default:
        return FiActivity;
    }
  };
  
  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    }).format(date);
  };
  
  return (
    <Flex
      p={3}
      mb={3}
      bg={bgColor}
      borderRadius="md"
      borderWidth="1px"
      borderColor={borderColor}
      align="center"
    >
      <Icon as={getActivityIcon(activity.type)} boxSize={5} mr={3} color="brand.500" />
      <Box flex="1">
        <Text fontSize="sm" fontWeight="medium" noOfLines={1}>
          {activity.title}
        </Text>
        <Text fontSize="xs" color="gray.500">
          {formatDate(activity.timestamp)}
        </Text>
      </Box>
    </Flex>
  );
}

export default Dashboard;

// src/pages/Summarizer.js
import React, { useState } from 'react';
import {
  Box,
  Button,
  Flex,
  FormControl,
  FormLabel,
  Heading,
  HStack,
  Radio,
  RadioGroup,
  Select,
  Stack,
  Switch,
  Text,
  Textarea,
  FormHelperText,
  useColorModeValue,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  useToast,
  Tabs,
  TabList,
  Tab,
  TabPanels,
  TabPanel,
} from '@chakra-ui/react';
import FileUpload from '../components/FileUpload';
import ResultViewer from '../components/ResultViewer';
import { useAppContext } from '../context/AppContext';

function Summarizer() {
  const [text, setText] = useState('');
  const [files, setFiles] = useState([]);
  const [model, setModel] = useState('advanced');
  const [maxTokens, setMaxTokens] = useState(200);
  const [minTokens, setMinTokens] = useState(50);
  const [extractEntities, setExtractEntities] = useState(true);
  const [summaryLevels, setSummaryLevels] = useState(['tag', 'sentence', 'paragraph']);
  const [result, setResult] = useState(null);
  const [activeTab, setActiveTab] = useState('text');
  
  const { apiRequest, isLoading, error } = useAppContext();
  const toast = useToast();
  
  const handleTextChange = (e) => {
    setText(e.target.value);
  };
  
  const handleFileChange = (fileList) => {
    setFiles(fileList);
  };
  
  const handleSummaryLevelChange = (level) => {
    if (summaryLevels.includes(level)) {
      setSummaryLevels(summaryLevels.filter(l => l !== level));
    } else {
      setSummaryLevels([...summaryLevels, level]);
    }
  };
  
  const handleSubmit = async () => {
    if (activeTab === 'text' && !text.trim()) {
      toast({
        title: 'Error',
        description: 'Please enter some text to summarize',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    if (activeTab === 'file' && files.length === 0) {
      toast({
        title: 'Error',
        description: 'Please upload a file to summarize',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    try {
      // Prepare request data
      let requestData;
      
      if (activeTab === 'text') {
        requestData = {
          text,
          model,
          config: {
            maxTokens,
            minTokens,
            summaryLevels,
            extractEntities: model === 'advanced' && extractEntities,
          },
        };
        
        // Make API request
        const response = await apiRequest('process_text', 'POST', requestData);
        setResult(response);
      } else {
        // File upload logic
        const formData = new FormData();
        formData.append('file', files[0]);
        formData.append('model', model);
        formData.append('maxTokens', maxTokens);
        formData.append('minTokens', minTokens);
        formData.append('summaryLevels', JSON.stringify(summaryLevels));
        formData.append('extractEntities', model === 'advanced' && extractEntities);
        
        // Make API request
        const response = await apiRequest('process_file', 'POST', formData);
        setResult(response);
      }
      
      toast({
        title: 'Success',
        description: 'Text has been successfully summarized',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'An error occurred during summarization',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  return (
    <Box>
      <Heading size="lg" mb={6}>Summarizer</Heading>
      
      <Box
        p={6}
        bg={bgColor}
        borderRadius="lg"
        borderWidth="1px"
        borderColor={borderColor}
        boxShadow="sm"
        mb={6}
      >
        <Tabs variant="soft-rounded" colorScheme="brand" mb={4} onChange={(index) => setActiveTab(index === 0 ? 'text' : 'file')}>
          <TabList>
            <Tab>Text Input</Tab>
            <Tab>File Upload</Tab>
          </TabList>
          
          <TabPanels>
            <TabPanel p={0} pt={4}>
              <FormControl mb={4}>
                <FormLabel>Text to Summarize</FormLabel>
                <Textarea
                  value={text}
                  onChange={handleTextChange}
                  placeholder="Enter text to summarize..."
                  minH="200px"
                  resize="vertical"
                />
              </FormControl>
            </TabPanel>
            
            <TabPanel p={0} pt={4}>
              <FileUpload onFileChange={handleFileChange} multiple={false} />
            </TabPanel>
          </TabPanels>
        </Tabs>
        
        <Flex direction={{ base: 'column', md: 'row' }} gap={6}>
          <Box flex={1}>
            <FormControl mb={4}>
              <FormLabel>Summarization Model</FormLabel>
              <RadioGroup value={model} onChange={setModel}>
                <Stack direction="row">
                  <Radio value="simple">Simple</Radio>
                  <Radio value="advanced">Advanced</Radio>
                </Stack>
              </RadioGroup>
              <FormHelperText>
                Advanced model enables entity extraction and improved semantic understanding
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4} isDisabled={model !== 'advanced'}>
              <FormLabel>Extract Entities</FormLabel>
              <Switch
                isChecked={extractEntities}
                onChange={() => setExtractEntities(!extractEntities)}
                colorScheme="brand"
              />
              <FormHelperText>
                Identify and extract named entities from the text
              </FormHelperText>
            </FormControl>
          </Box>
          
          <Box flex={1}>
            <FormControl mb={4}>
              <FormLabel>Max Tokens</FormLabel>
              <NumberInput
                value={maxTokens}
                onChange={(valueString) => setMaxTokens(parseInt(valueString))}
                min={50}
                max={500}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Maximum number of tokens in summary
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Min Tokens</FormLabel>
              <NumberInput
                value={minTokens}
                onChange={(valueString) => setMinTokens(parseInt(valueString))}
                min={10}
                max={maxTokens - 10}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Minimum number of tokens in summary
              </FormHelperText>
            </FormControl>
          </Box>
        </Flex>
        
        <FormControl mb={4}>
          <FormLabel>Summary Levels</FormLabel>
          <HStack spacing={4}>
            <Flex>
              <Switch
                isChecked={summaryLevels.includes('tag')}
                onChange={() => handleSummaryLevelChange('tag')}
                colorScheme="brand"
                mr={2}
              />
              <Text>Tags</Text>
            </Flex>
            
            <Flex>
              <Switch
                isChecked={summaryLevels.includes('sentence')}
                onChange={() => handleSummaryLevelChange('sentence')}
                colorScheme="brand"
                mr={2}
              />
              <Text>One-Sentence</Text>
            </Flex>
            
            <Flex>
              <Switch
                isChecked={summaryLevels.includes('paragraph')}
                onChange={() => handleSummaryLevelChange('paragraph')}
                colorScheme="brand"
                mr={2}
              />
              <Text>Paragraph</Text>
            </Flex>
          </HStack>
          <FormHelperText>
            Select the summary levels to generate
          </FormHelperText>
        </FormControl>
        
        <Button
          mt={4}
          colorScheme="brand"
          isLoading={isLoading}
          onClick={handleSubmit}
        >
          Summarize
        </Button>
      </Box>
      
      {result && (
        <ResultViewer data={result} title="Summary Results" />
      )}
    </Box>
  );
}

export default Summarizer;

// src/pages/TopicModeling.js
import React, { useState } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Heading,
  Select,
  Stack,
  Switch,
  Text,
  Textarea,
  FormHelperText,
  useColorModeValue,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  useToast,
  Tabs,
  TabList,
  Tab,
  TabPanels,
  TabPanel,
  SimpleGrid,
  Flex,
} from '@chakra-ui/react';
import FileUpload from '../components/FileUpload';
import ResultViewer from '../components/ResultViewer';
import { useAppContext } from '../context/AppContext';

function TopicModeling() {
  const [text, setText] = useState('');
  const [files, setFiles] = useState([]);
  const [algorithm, setAlgorithm] = useState('lda');
  const [numTopics, setNumTopics] = useState(5);
  const [topTerms, setTopTerms] = useState(10);
  const [autoOptimize, setAutoOptimize] = useState(false);
  const [result, setResult] = useState(null);
  const [activeTab, setActiveTab] = useState('text');
  
  const { apiRequest, isLoading, error } = useAppContext();
  const toast = useToast();
  
  const handleTextChange = (e) => {
    setText(e.target.value);
  };
  
  const handleFileChange = (fileList) => {
    setFiles(fileList);
  };
  
  const handleSubmit = async () => {
    if (activeTab === 'text' && !text.trim()) {
      toast({
        title: 'Error',
        description: 'Please enter some text for topic modeling',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    if (activeTab === 'file' && files.length === 0) {
      toast({
        title: 'Error',
        description: 'Please upload at least one file for topic modeling',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    try {
      // Prepare request data
      let requestData;
      
      if (activeTab === 'text') {
        // Split text by paragraphs to create multiple documents
        const documents = text
          .split(/\n\s*\n/)
          .filter(doc => doc.trim().length > 0);
        
        if (documents.length === 0) {
          documents.push(text);
        }
        
        requestData = {
          documents,
          algorithm,
          numTopics,
          topTerms,
          autoOptimize,
        };
        
        // Make API request
        const response = await apiRequest('analyze_topics', 'POST', requestData);
        setResult(response);
      } else {
        // File upload logic
        const formData = new FormData();
        
        for (let i = 0; i < files.length; i++) {
          formData.append('files', files[i]);
        }
        
        formData.append('algorithm', algorithm);
        formData.append('numTopics', numTopics);
        formData.append('topTerms', topTerms);
        formData.append('autoOptimize', autoOptimize);
        
        // Make API request
        const response = await apiRequest('analyze_topics_files', 'POST', formData);
        setResult(response);
      }
      
      toast({
        title: 'Success',
        description: 'Topic modeling completed successfully',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'An error occurred during topic modeling',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  return (
    <Box>
      <Heading size="lg" mb={6}>Topic Modeling</Heading>
      
      <Box
        p={6}
        bg={bgColor}
        borderRadius="lg"
        borderWidth="1px"
        borderColor={borderColor}
        boxShadow="sm"
        mb={6}
      >
        <Tabs variant="soft-rounded" colorScheme="brand" mb={4} onChange={(index) => setActiveTab(index === 0 ? 'text' : 'file')}>
          <TabList>
            <Tab>Text Input</Tab>
            <Tab>File Upload</Tab>
          </TabList>
          
          <TabPanels>
            <TabPanel p={0} pt={4}>
              <FormControl mb={4}>
                <FormLabel>Text for Topic Modeling</FormLabel>
                <Textarea
                  value={text}
                  onChange={handleTextChange}
                  placeholder="Enter text for topic modeling..."
                  minH="200px"
                  resize="vertical"
                />
                <FormHelperText>
                  For best results, provide multiple paragraphs or documents separated by blank lines
                </FormHelperText>
              </FormControl>
            </TabPanel>
            
            <TabPanel p={0} pt={4}>
              <FileUpload 
                onFileChange={handleFileChange} 
                multiple={true} 
                accept=".txt,.pdf,.doc,.docx,.json,.csv,.md"
              />
              <FormHelperText mt={2}>
                Upload multiple files for better topic modeling results
              </FormHelperText>
            </TabPanel>
          </TabPanels>
        </Tabs>
        
        <SimpleGrid columns={{ base: 1, md: 2 }} spacing={6}>
          <Box>
            <FormControl mb={4}>
              <FormLabel>Algorithm</FormLabel>
              <Select value={algorithm} onChange={(e) => setAlgorithm(e.target.value)}>
                <option value="lda">Latent Dirichlet Allocation (LDA)</option>
                <option value="nmf">Non-negative Matrix Factorization (NMF)</option>
                <option value="lsa">Latent Semantic Analysis (LSA)</option>
              </Select>
              <FormHelperText>
                {algorithm === 'lda' && 'Best for general purpose topic modeling with probabilistic approach'}
                {algorithm === 'nmf' && 'Works well for more distinct, non-overlapping topics'}
                {algorithm === 'lsa' && 'Efficient for large document collections with SVD'}
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Auto-optimize Parameters</FormLabel>
              <Switch
                isChecked={autoOptimize}
                onChange={() => setAutoOptimize(!autoOptimize)}
                colorScheme="brand"
              />
              <FormHelperText>
                Automatically tune model hyperparameters for better results (takes longer)
              </FormHelperText>
            </FormControl>
          </Box>
          
          <Box>
            <FormControl mb={4}>
              <FormLabel>Number of Topics</FormLabel>
              <NumberInput
                value={numTopics}
                onChange={(valueString) => setNumTopics(parseInt(valueString))}
                min={2}
                max={20}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Number of topics to extract (2-20)
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Top Terms Per Topic</FormLabel>
              <NumberInput
                value={topTerms}
                onChange={(valueString) => setTopTerms(parseInt(valueString))}
                min={5}
                max={50}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Number of terms to show for each topic
              </FormHelperText>
            </FormControl>
          </Box>
        </SimpleGrid>
        
        <Button
          mt={4}
          colorScheme="brand"
          isLoading={isLoading}
          onClick={handleSubmit}
        >
          Extract Topics
        </Button>
      </Box>
      
      {result && (
        <ResultViewer data={result} title="Topic Modeling Results" />
      )}
    </Box>
  );
}

export default TopicModeling;

// src/pages/KnowledgeGraph.js
import React, { useState, useRef } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Heading,
  Select,
  Stack,
  Switch,
  Text,
  Textarea,
  FormHelperText,
  useColorModeValue,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  useToast,
  Tabs,
  TabList,
  Tab,
  TabPanels,
  TabPanel,
  SimpleGrid,
  Flex,
} from '@chakra-ui/react';
import FileUpload from '../components/FileUpload';
import { useAppContext } from '../context/AppContext';

function KnowledgeGraph() {
  const [text, setText] = useState('');
  const [files, setFiles] = useState([]);
  const [entities, setEntities] = useState(true);
  const [topics, setTopics] = useState(true);
  const [maxEntities, setMaxEntities] = useState(100);
  const [minEdgeWeight, setMinEdgeWeight] = useState(0.2);
  const [layout, setLayout] = useState('spring');
  const [interactive, setInteractive] = useState(true);
  const [activeTab, setActiveTab] = useState('text');
  const [graphUrl, setGraphUrl] = useState(null);
  
  const iframeRef = useRef(null);
  
  const { apiRequest, isLoading, error } = useAppContext();
  const toast = useToast();
  
  const handleTextChange = (e) => {
    setText(e.target.value);
  };
  
  const handleFileChange = (fileList) => {
    setFiles(fileList);
  };
  
  const handleSubmit = async () => {
    if (activeTab === 'text' && !text.trim()) {
      toast({
        title: 'Error',
        description: 'Please enter some text for knowledge graph generation',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    if (activeTab === 'file' && files.length === 0) {
      toast({
        title: 'Error',
        description: 'Please upload a file for knowledge graph generation',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    try {
      // Prepare request data
      let formData = new FormData();
      
      if (activeTab === 'text') {
        formData.append('text', text);
      } else {
        formData.append('file', files[0]);
      }
      
      // Add parameters
      formData.append('entities', entities);
      formData.append('topics', topics);
      formData.append('maxEntities', maxEntities);
      formData.append('minEdgeWeight', minEdgeWeight);
      formData.append('layout', layout);
      formData.append('interactive', interactive);
      
      // Make API request
      const response = await apiRequest('graph', 'POST', formData);
      
      if (response && response.visualization_url) {
        setGraphUrl(response.visualization_url);
        
        toast({
          title: 'Success',
          description: 'Knowledge graph generated successfully',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
      } else {
        throw new Error('No visualization URL in response');
      }
    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'An error occurred during knowledge graph generation',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  return (
    <Box>
      <Heading size="lg" mb={6}>Knowledge Graph</Heading>
      
      <Box
        p={6}
        bg={bgColor}
        borderRadius="lg"
        borderWidth="1px"
        borderColor={borderColor}
        boxShadow="sm"
        mb={6}
      >
        <Tabs variant="soft-rounded" colorScheme="brand" mb={4} onChange={(index) => setActiveTab(index === 0 ? 'text' : 'file')}>
          <TabList>
            <Tab>Text Input</Tab>
            <Tab>File Upload</Tab>
          </TabList>
          
          <TabPanels>
            <TabPanel p={0} pt={4}>
              <FormControl mb={4}>
                <FormLabel>Text for Knowledge Graph</FormLabel>
                <Textarea
                  value={text}
                  onChange={handleTextChange}
                  placeholder="Enter text to generate knowledge graph..."
                  minH="200px"
                  resize="vertical"
                />
              </FormControl>
            </TabPanel>
            
            <TabPanel p={0} pt={4}>
              <FileUpload 
                onFileChange={handleFileChange} 
                multiple={false} 
                accept=".txt,.pdf,.doc,.docx,.json,.csv,.md"
              />
            </TabPanel>
          </TabPanels>
        </Tabs>
        
        <SimpleGrid columns={{ base: 1, md: 2 }} spacing={6}>
          <Box>
            <FormControl mb={4}>
              <FormLabel>Extract Entities</FormLabel>
              <Switch
                isChecked={entities}
                onChange={() => setEntities(!entities)}
                colorScheme="brand"
              />
              <FormHelperText>
                Extract named entities for the graph
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Include Topics</FormLabel>
              <Switch
                isChecked={topics}
                onChange={() => setTopics(!topics)}
                colorScheme="brand"
              />
              <FormHelperText>
                Include topic nodes in the graph
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Maximum Entities</FormLabel>
              <NumberInput
                value={maxEntities}
                onChange={(valueString) => setMaxEntities(parseInt(valueString))}
                min={10}
                max={500}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Maximum number of entities in the graph
              </FormHelperText>
            </FormControl>
          </Box>
          
          <Box>
            <FormControl mb={4}>
              <FormLabel>Minimum Edge Weight</FormLabel>
              <NumberInput
                value={minEdgeWeight}
                onChange={(valueString) => setMinEdgeWeight(parseFloat(valueString))}
                min={0.1}
                max={1.0}
                step={0.1}
                precision={1}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Minimum relationship strength (0.1-1.0)
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Layout</FormLabel>
              <Select value={layout} onChange={(e) => setLayout(e.target.value)}>
                <option value="spring">Spring (Force-directed)</option>
                <option value="circular">Circular</option>
                <option value="kamada_kawai">Kamada-Kawai</option>
                <option value="spectral">Spectral</option>
              </Select>
              <FormHelperText>
                Graph layout algorithm
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Interactive Visualization</FormLabel>
              <Switch
                isChecked={interactive}
                onChange={() => setInteractive(!interactive)}
                colorScheme="brand"
              />
              <FormHelperText>
                Generate interactive HTML visualization
              </FormHelperText>
            </FormControl>
          </Box>
        </SimpleGrid>
        
        <Button
          mt={4}
          colorScheme="brand"
          isLoading={isLoading}
          onClick={handleSubmit}
        >
          Generate Knowledge Graph
        </Button>
      </Box>
      
      {graphUrl && (
        <Box
          borderWidth="1px"
          borderColor={borderColor}
          borderRadius="lg"
          overflow="hidden"
          boxShadow="sm"
          bg={bgColor}
        >
          <Box p={4} borderBottomWidth="1px" borderColor={borderColor}>
            <Heading size="md">Knowledge Graph Visualization</Heading>
          </Box>
          
          <Box height="600px">
            <iframe 
              ref={iframeRef}
              src={graphUrl} 
              width="100%" 
              height="100%" 
              frameBorder="0"
              title="Knowledge Graph Visualization"
            />
          </Box>
        </Box>
      )}
    </Box>
  );
}

export default KnowledgeGraph;

// src/pages/TemporalAnalysis.js
import React, { useState } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Heading,
  Select,
  Stack,
  Switch,
  Text,
  Input,
  FormHelperText,
  useColorModeValue,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  useToast,
  SimpleGrid,
  Flex,
} from '@chakra-ui/react';
import FileUpload from '../components/FileUpload';
import { useAppContext } from '../context/AppContext';

function TemporalAnalysis() {
  const [files, setFiles] = useState([]);
  const [dateFormat, setDateFormat] = useState('%Y-%m-%d');
  const [dateField, setDateField] = useState('date');
  const [filenamePattern, setFilenamePattern] = useState('');
  const [period, setPeriod] = useState('month');
  const [minDocuments, setMinDocuments] = useState(2);
  const [smoothing, setSmoothing] = useState(1);
  const [analyzeTopics, setAnalyzeTopics] = useState(true);
  const [analyzeEntities, setAnalyzeEntities] = useState(true);
  const [analyzeSentiment, setAnalyzeSentiment] = useState(true);
  const [generateReport, setGenerateReport] = useState(true);
  const [reportUrl, setReportUrl] = useState(null);
  
  const { apiRequest, isLoading, error } = useAppContext();
  const toast = useToast();
  
  const handleFileChange = (fileList) => {
    setFiles(fileList);
  };
  
  const handleSubmit = async () => {
    if (files.length === 0) {
      toast({
        title: 'Error',
        description: 'Please upload files for temporal analysis',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    try {
      // Prepare form data
      const formData = new FormData();
      
      // Add files
      for (let i = 0; i < files.length; i++) {
        formData.append('files', files[i]);
      }
      
      // Add parameters
      formData.append('dateFormat', dateFormat);
      formData.append('dateField', dateField);
      formData.append('filenamePattern', filenamePattern);
      formData.append('period', period);
      formData.append('minDocuments', minDocuments);
      formData.append('smoothing', smoothing);
      formData.append('analyzeTopics', analyzeTopics);
      formData.append('analyzeEntities', analyzeEntities);
      formData.append('analyzeSentiment', analyzeSentiment);
      formData.append('generateReport', generateReport);
      
      // Make API request
      const response = await apiRequest('temporal', 'POST', formData);
      
      if (response && response.report_url) {
        setReportUrl(response.report_url);
        
        toast({
          title: 'Success',
          description: 'Temporal analysis completed successfully',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
      } else {
        throw new Error('No report URL in response');
      }
    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'An error occurred during temporal analysis',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  return (
    <Box>
      <Heading size="lg" mb={6}>Temporal Analysis</Heading>
      
      <Box
        p={6}
        bg={bgColor}
        borderRadius="lg"
        borderWidth="1px"
        borderColor={borderColor}
        boxShadow="sm"
        mb={6}
      >
        <FileUpload 
          onFileChange={handleFileChange} 
          multiple={true} 
          accept=".txt,.pdf,.doc,.docx,.json,.csv,.md"
        />
        <FormHelperText mt={2} mb={6}>
          Upload multiple files with dates in filename or content
        </FormHelperText>
        
        <SimpleGrid columns={{ base: 1, md: 2 }} spacing={6}>
          <Box>
            <FormControl mb={4}>
              <FormLabel>Date Format</FormLabel>
              <Input
                value={dateFormat}
                onChange={(e) => setDateFormat(e.target.value)}
                placeholder="%Y-%m-%d"
              />
              <FormHelperText>
                Format string for dates (e.g., %Y-%m-%d for 2023-01-01)
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Date Field</FormLabel>
              <Input
                value={dateField}
                onChange={(e) => setDateField(e.target.value)}
                placeholder="date"
              />
              <FormHelperText>
                Field name for date in JSON/CSV input
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Filename Pattern</FormLabel>
              <Input
                value={filenamePattern}
                onChange={(e) => setFilenamePattern(e.target.value)}
                placeholder=".*_([0-9]{4}-[0-9]{2}-[0-9]{2}).*"
              />
              <FormHelperText>
                Regex pattern to extract date from filename
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Time Period</FormLabel>
              <Select value={period} onChange={(e) => setPeriod(e.target.value)}>
                <option value="day">Day</option>
                <option value="week">Week</option>
                <option value="month">Month</option>
                <option value="year">Year</option>
              </Select>
              <FormHelperText>
                Time period granularity
              </FormHelperText>
            </FormControl>
          </Box>
          
          <Box>
            <FormControl mb={4}>
              <FormLabel>Minimum Documents per Period</FormLabel>
              <NumberInput
                value={minDocuments}
                onChange={(valueString) => setMinDocuments(parseInt(valueString))}
                min={1}
                max={10}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Minimum number of documents required for a period
              </FormHelperText>
            </FormControl>
            
            <FormControl mb={4}>
              <FormLabel>Smoothing Window</FormLabel>
              <NumberInput
                value={smoothing}
                onChange={(valueString) => setSmoothing(parseInt(valueString))}
                min={0}
                max={5}
              >
                <NumberInputField />
                <NumberInputStepper>
                  <NumberIncrementStepper />
                  <NumberDecrementStepper />
                </NumberInputStepper>
              </NumberInput>
              <FormHelperText>
                Window size for trend smoothing (0 for no smoothing)
              </FormHelperText>
            </FormControl>
            
            <SimpleGrid columns={2} spacing={4} mb={4}>
              <FormControl>
                <FormLabel>Analyze Topics</FormLabel>
                <Switch
                  isChecked={analyzeTopics}
                  onChange={() => setAnalyzeTopics(!analyzeTopics)}
                  colorScheme="brand"
                />
              </FormControl>
              
              <FormControl>
                <FormLabel>Analyze Entities</FormLabel>
                <Switch
                  isChecked={analyzeEntities}
                  onChange={() => setAnalyzeEntities(!analyzeEntities)}
                  colorScheme="brand"
                />
              </FormControl>
              
              <FormControl>
                <FormLabel>Analyze Sentiment</FormLabel>
                <Switch
                  isChecked={analyzeSentiment}
                  onChange={() => setAnalyzeSentiment(!analyzeSentiment)}
                  colorScheme="brand"
                />
              </FormControl>
              
              <FormControl>
                <FormLabel>Generate Report</FormLabel>
                <Switch
                  isChecked={generateReport}
                  onChange={() => setGenerateReport(!generateReport)}
                  colorScheme="brand"
                />
              </FormControl>
            </SimpleGrid>
          </Box>
        </SimpleGrid>
        
        <Button
          mt={4}
          colorScheme="brand"
          isLoading={isLoading}
          onClick={handleSubmit}
        >
          Run Temporal Analysis
        </Button>
      </Box>
      
      {reportUrl && (
        <Box
          borderWidth="1px"
          borderColor={borderColor}
          borderRadius="lg"
          overflow="hidden"
          boxShadow="sm"
          bg={bgColor}
        >
          <Box p={4} borderBottomWidth="1px" borderColor={borderColor}>
            <Heading size="md">Temporal Analysis Report</Heading>
          </Box>
          
          <Box height="600px">
            <iframe 
              src={reportUrl} 
              width="100%" 
              height="100%" 
              frameBorder="0"
              title="Temporal Analysis Report"
            />
          </Box>
        </Box>
      )}
    </Box>
  );
}

export default TemporalAnalysis;

// src/pages/EntityExtraction.js
import React, { useState } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Heading,
  Stack,
  Text,
  Textarea,
  FormHelperText,
  useColorModeValue,
  useToast,
  Tabs,
  TabList,
  Tab,
  TabPanels,
  TabPanel,
  SimpleGrid,
  Flex,
  Select,
  Switch,
} from '@chakra-ui/react';
import FileUpload from '../components/FileUpload';
import ResultViewer from '../components/ResultViewer';
import { useAppContext } from '../context/AppContext';

function EntityExtraction() {
  const [text, setText] = useState('');
  const [files, setFiles] = useState([]);
  const [model, setModel] = useState('standard');
  const [includeRelationships, setIncludeRelationships] = useState(true);
  const [result, setResult] = useState(null);
  const [activeTab, setActiveTab] = useState('text');
  
  const { apiRequest, isLoading, error } = useAppContext();
  const toast = useToast();
  
  const handleTextChange = (e) => {
    setText(e.target.value);
  };
  
  const handleFileChange = (fileList) => {
    setFiles(fileList);
  };
  
  const handleSubmit = async () => {
    if (activeTab === 'text' && !text.trim()) {
      toast({
        title: 'Error',
        description: 'Please enter some text for entity extraction',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    if (activeTab === 'file' && files.length === 0) {
      toast({
        title: 'Error',
        description: 'Please upload a file for entity extraction',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    try {
      // Prepare request data
      let requestData;
      
      if (activeTab === 'text') {
        requestData = {
          text,
          model,
          includeRelationships,
        };
        
        // Make API request
        const response = await apiRequest('extract_entities', 'POST', requestData);
        setResult(response);
      } else {
        // File upload logic
        const formData = new FormData();
        formData.append('file', files[0]);
        formData.append('model', model);
        formData.append('includeRelationships', includeRelationships);
        
        // Make API request
        const response = await apiRequest('extract_entities_file', 'POST', formData);
        setResult(response);
      }
      
      toast({
        title: 'Success',
        description: 'Entities extracted successfully',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      toast({
        title: 'Error',
        description: error.message || 'An error occurred during entity extraction',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
    }
  };
  
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  
  return (
    <Box>
      <Heading size="lg" mb={6}>Entity Extraction</Heading>
      
      <Box
        p={6}
        bg={bgColor}
        borderRadius="lg"
        borderWidth="1px"
        borderColor={borderColor}
        boxShadow="sm"
        mb={6}
      >
        <Tabs variant="soft-rounded" colorScheme="brand" mb={4} onChange={(index) => setActiveTab(index === 0 ? 'text' : 'file')}>
          <TabList>
            <Tab>Text Input</Tab>
            <Tab>File Upload</Tab>
          </TabList>
          
          <TabPanels>
            <TabPanel p={0} pt={4}>
              <FormControl mb={4}>
                <FormLabel>Text for Entity Extraction</FormLabel>
                <Textarea
                  value={text}
                  onChange={handleTextChange}
                  placeholder="Enter text to extract entities..."
                  minH="200px"
                  resize="vertical"
                />
              </FormControl>
            </TabPanel>
            
            <TabPanel p={0} pt={4}>
              <FileUpload 
                onFileChange={handleFileChange} 
                multiple={false} 
                accept=".txt,.pdf,.doc,.docx,.json,.csv,.md"
              />
            </TabPanel>
          </TabPanels>
        </Tabs>
        
        <SimpleGrid columns={{ base: 1, md: 2 }} spacing={6}>
          <FormControl mb={4}>
            <FormLabel>Entity Recognition Model</FormLabel>
            <Select value={model} onChange={(e) => setModel(e.target.value)}>
              <option value="standard">Standard (General Purpose)</option>
              <option value="large">Large (More Accurate)</option>
              <option value="scientific">Scientific/Academic</option>
              <option value="legal">Legal Documents</option>
              <option value="medical">Medical Texts</option>
            </Select>
            <FormHelperText>
              Choose the model best suited for your content
            </FormHelperText>
          </FormControl>
          
          <FormControl mb={4}>
            <FormLabel>Include Relationships</FormLabel>
            <Switch
              isChecked={includeRelationships}
              onChange={() => setIncludeRelationships(!includeRelationships)}
              colorScheme="brand"
            />
            <FormHelperText>
              Extract relationships between entities
            </FormHelperText>
          </FormControl>
        </SimpleGrid>
        
        <Button
          mt={4}
          colorScheme="brand"
          isLoading={isLoading}
          onClick={handleSubmit}
        >
          Extract Entities
        </Button>
      </Box>
      
      {result && (
        <ResultViewer data={result} title="Entity Extraction Results" />
      )}
    </Box>
  );
}

export default EntityExtraction;

// src/pages/BatchProcessor.js
import React, { useState } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Heading,
  Select,
  Switch,
  Text,
  FormHelperText,
  useColorModeValue,
  useToast,
  SimpleGrid,
  Flex,
  NumberInput,
  NumberInputField,
  NumberInputStepper,
  NumberIncrementStepper,
  NumberDecrementStepper,
  Progress,
  Tag,
  Table,
  Thead,
  Tbody,
  Tr,
  Th,
  Td,
  HStack,
  Link,
} from '@chakra-ui/react';
import { FiDownload, FiEye } from 'react-icons/fi';
import FileUpload from '../components/FileUpload';
import { useAppContext } from '../context/AppContext';

function BatchProcessor() {
  const [files, setFiles] = useState([]);
  const [outputDir, setOutputDir] = useState('');
  const [summarize, setSummarize] = useState(true);
  const [topics, setTopics] = useState(false);
  const [graph, setGraph] = useState(false);
  const [model, setModel] = useState('advanced');
  const [workers, setWorkers] = useState(4);
  const [processingStatus, setProcessingStatus] = useState(null);
  const [results, setResults] = useState([]);
  
  const { apiRequest, isLoading, error } = useAppContext();
  const toast = useToast();
  
  const handleFileChange = (fileList) => {
    setFiles(fileList);
  };
  
  const handleSubmit = async () => {
    if (files.length === 0) {
      toast({
        title: 'Error',
        description: 'Please upload files for batch processing',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    if (!summarize && !topics && !graph) {
      toast({
        title: 'Error',
        description: 'Please select at least one operation to perform',
        status: 'error',
        duration: 3000,
        isClosable: true,
      });
      return;
    }
    
    try {
      // Create temporary output directory if not specified
      const tempOutputDir = outputDir || `batch_${Date.now()}`;
      
      // Initialize processing status
      setProcessingStatus({
        totalFiles: files.length,
        processedFiles: 0,
        progress: 0,
        status: 'processing'
      });
      
      // Prepare